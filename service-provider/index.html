<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>
      Wattt
    </title>
    <link rel="stylesheet" href="styles.css" />

    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="./generate-address.js"></script>

    <!-- Place iota-bindings-emscripten.wasm in -->
    <!-- ./lib/iota-bindings-emscripten.wasm and mam.web.js in ./mam.web.js. -->
    <script src="node_modules/iota.lib.js/dist/iota.js"></script>
    <script src="node_modules/mam.client.js/lib/mam.web.js"></script>

    <script>

     let IS_AUTHORIZED = false;

     const ADDRESS_COOKIE_NAME = 'wattt-iota-address';
     const MAM_DATA_TYPE = 'MAM_DATA';

     const getAddress = () => Cookies.get(ADDRESS_COOKIE_NAME);

     const setAddress = (address) => {
       console.log(`Setting address ${address} in cookie and hidden field...`);
       Cookies.set(ADDRESS_COOKIE_NAME, address);
       const addressBox = document.getElementById('address-hidden-box');
       addressBox.value = address;
     }

     const requestAuthorization = () => {
       const address = document.getElementById('address-hidden-box').value;
       const url = window.location.href;
       const goal = document.getElementById('goal-text-box').value;
       window.location = `http://localhost:3000/new-policy?iotaAddress=${address}&url=${url}&goal=${goal}`;
     }

     const iota = new IOTA({ provider: 'http://node01.testnet.iotatoken.nl:16265' });

     // Wait for streaming compile of MAM library before initializing
     const MAX_STREAMING_COMPILE_TIME_MS = 3000;
     setTimeout(() => Mam.init(iota), MAX_STREAMING_COMPILE_TIME_MS);

     const fromTrytes = (trytes) => {
       const isOdd = n => (n % 2) === 1;

       // Work around odd length trytes that cannot be converted by appending a 9
       if (isOdd(trytes.length)) {
         return iota.utils.fromTrytes(`${trytes}9`);
       }

       return iota.utils.fromTrytes(trytes);
     }

     const toDate = timestamp => new Date(timestamp);

     const toElectricityUsage = (telegram) => {
       // 1.7.0 is OBIS code for positive active instantaneous power (A+) [kW]
       const CAPTURE_USAGE_PATTERN = /1.7.0\((.{7})\*kW\)/
       const value = CAPTURE_USAGE_PATTERN.exec(telegram)[1];

       return parseFloat(value);
     }

     /**
      * Gets last received transfer message.
      * NOTE: order is not necessarily chronological, but let's assume it is.
      *
      * @function getLastMessage
      * @param {string} address Our IOTA address
      * @returns {JSON} Parsed message or `null` when no received transfers
      */
     function getLastMessage(address) {
       return new Promise((resolve, reject) => {
         iota.api.findTransactionObjects({ addresses: [address] }, (err, transactions) => {
           if (err) return reject(err);
           if (!transactions || transactions.length === 0) return reject(new Error('No transactions retrieved.'));

           const sortedTransactions = transactions.sort((a, b) => b.timestamp - a.timestamp);
           const lastTransaction = sortedTransactions[0];
           const message = JSON.parse(iota.utils.extractJson([lastTransaction]));
           const messageWithTimeStamp = { ...message, timestamp: lastTransaction.timestamp };

           return resolve(messageWithTimeStamp);
         });
       });
     }

     const seenMessages = new Set(); // mutable set
     const processMessage = () => {
       const address = document.getElementById('address-hidden-box').value;
       console.log(`Getting last message from address ${address}...`);

       if (address === "") {
         console.log('No address so cannot process message');
         return;
       }

       getLastMessage(address)
        .then((msg) => {
          if (!msg) {
            console.log('No messages');
            return null;
          }

          // To avoid processing the same last message over and over we keep track
          // of already processed messages (note: stringified versions so set
          // operations that use equals (like set.has()) work as intended)
          if (seenMessages.has(JSON.stringify(msg))) {
            console.log('No new messages');
            return null;
          }
          seenMessages.add(JSON.stringify(msg));

          console.log(`Received new message of type ${msg.type}`);
          switch (msg.type) {
            case MAM_DATA_TYPE:
            {
              document.getElementById('root-text-box').value = msg.mamData.root;
              document.getElementById('side-key-text-box').value = msg.mamData.sideKey;
              break;
            }
            default:
            {
              throw new Error(`Unknown message type: ${msg.type}`);
            }
        }
      })
        .catch(console.log); // eslint-disable-line no-console
     }

     const processMamMessage = () => {
       const root = document.getElementById('root-text-box').value;
       const sideKey = document.getElementById('side-key-text-box').value;
       const mode = 'restricted';

       IS_AUTHORIZED = (root !== "" && sideKey !== "");

       if (!IS_AUTHORIZED) {
         console.log('No authorization received');
         return;
       }
       console.log(`Trying to fetch from root ${root} with side key ${sideKey}`);

       Mam
         .fetch(root, mode, sideKey)
         .then(({ nextRoot, messages }) => {
           const jsonMessages = messages.map(m => JSON.parse(fromTrytes(m)));

           const usage = jsonMessages.map(m => ({
               date: toDate(m.timestamp),
               value: toElectricityUsage(m.raw),
             }));

           console.log(`Messages is ${messages}`);
           console.log(`Next root is ${nextRoot}`);
           console.log(`Usage is ${usage}`);

           if (usage && usage.length !== 0) {
             if (usage.length > 26) {
              return usage.slice(usage.length-26, usage.length-1);
             } else {
               return usage;
             }
           } else {
             throw new Error('No new data');
           }
         })
         .then(usage => drawLineChart('line-chart', usage))
         .catch(console.log);
     };

     setInterval(processMessage, 5000);
     setInterval(processMamMessage, 5000);
    </script>
  </head>
  <body>
    <div class="charts-container">
      <ul>
        <li class="chart">
          <h3 class="chart-sub-headline">Wattt P1 Insights</h3>
          <h2 class="chart-headline">Electricity usage (kW)</h2>
          <div id="line-chart">
            <svg id="line-chart-svg" class="line-chart-svg">
              <text x="30" y="30" font-size="30" dy="0">
                <tspan x="0" dy=".6em">NOT AUTHORIZED</tspan>
                <tspan x="0" dy="1.2em">Request consent via</tspan>
                <tspan x="0" dy="1.2em">the button below</tspan>
              </text>
              <defs>
                <linearGradient id="line-chart-gradient-background-area" x1="0" x2="0" y1="0" y2="1">
                  <stop class="line-chart-gradient-background-area-top" offset="0%" />
                  <stop class="line-chart-gradient-background-area-bottom" offset="100%" />
                </linearGradient>
              </defs>
            </svg>
          </div>
        </li>
      </ul>
    </div>
    <label for="root-text-box">
      Goal:
    </label>
    <input id="goal-text-box"
           type="text"
           size=100
           value="display your energy usage data in a fancy graph"
    />
    <br />
    <br />
    <button onclick="requestAuthorization()">
      Request data!
    </button>
    <br />
    <br />
    <input id="address-hidden-box" type="hidden" />
    <br />
    <label for="root-text-box">
      Received root:
    </label>
    <input id="root-text-box" type="text" disabled />
    <br />
    <label for="side-key-text-box">
      Received side key:
    </label>
    <input id="side-key-text-box" type="text" disabled />
    <script src="line-chart.js">
    </script>
    <script>
     // Get and set initial address
     const address = getAddress();

     if (address !== 'undefined') {
       setAddress(address);
     } else {
       const newAddress = generateAddressForTestingPurposes();
       setAddress(newAddress);
     }
    </script>
  </body>
</html>
