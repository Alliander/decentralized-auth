<!--
    Example of service provider that retrieves P1 energy data from a Raspberry
    Pi. The owner of the Pi has given consent to this service provider in My
    Home. My Home then provided the service provider with the side key and root
    of the restricted MAM channel where the device is publishing its energy data
    to. These initial MAM data is received via an MAM_DATA message on the
    service provider's IOTA address. The data is encrypted with the public key
    of the service provider, so that although IOTA messages are public, only the
    service provider can decrypt it. Since an MAM message contains the next root
    for further messages it can keep retrieving future data after the initial
    key exchange. Sometimes a message of type 'KEY_ROTATION' is received on the
    MAM stream. This means one of the service providers that has access to the
    stream had its access revoked and a new side key will be used on the
    restricted MAM channel. This KEY_ROTATION message contains the new side key
    encrypted with the public key of authorized service providers (they can see
    if they are still authorized by decrypting with their own key).

    This is plain JavaScript. The code stores its state in a cookie (its own
    address) and input fields (the device's received root and side key).
-->

<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>
      Wattt
    </title>
    <link rel="stylesheet" href="styles.css" />

    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="generate-address.js"></script>

    <script src="node_modules/iota.lib.js/dist/iota.js"></script>
    <script src="node_modules/mam.client.js/lib/mam.web.js"></script>

    <script type="text/javascript">

     let IS_AUTHORIZED = false;
     let ENERGY_USAGE_DATA = []; // Array of { date, value } tuples

     const ADDRESS_COOKIE_NAME = 'wattt-iota-address';
     const MAM_DATA_TYPE = 'MAM_DATA';

     const getAddress = () => Cookies.get(ADDRESS_COOKIE_NAME);

     const setAddress = (address) => {
       console.log(`Setting address ${address} in cookie...`);
       Cookies.set(ADDRESS_COOKIE_NAME, address);
     }

     const requestAuthorization = () => {
       const address = getAddress();
       const url = window.location.href;
       const goal = document.getElementById('goal-text-box').value;
       const myHouseUrl = `http://localhost:3000/new-policy?iotaAddress=${address}&url=${url}&goal=${goal}`;

       window.location = myHouseUrl;
     }

     const iota = new IOTA({ provider: 'http://node01.testnet.iotatoken.nl:16265' });

     const Mam = require('mam.web.js');
     Mam.init(iota);

     const fromTrytes = (trytes) => {
       const isOdd = n => (n % 2) === 1;

       // Work around odd length trytes that cannot be converted by appending a 9
       if (isOdd(trytes.length)) {
         return iota.utils.fromTrytes(`${trytes}9`);
       }

       return iota.utils.fromTrytes(trytes);
     }


     // Parse data message

     const toDate = timestamp => new Date(timestamp);

     const toElectricityUsage = (telegram) => {
       // 1.7.0 is OBIS code for positive active instantaneous power (A+) [kW]
       const CAPTURE_USAGE_PATTERN = /1.7.0\((.{7})\*kW\)/
       const value = CAPTURE_USAGE_PATTERN.exec(telegram)[1];

       return parseFloat(value);
     }

     /**
      * Gets last received transfer message.
      * NOTE: order is not necessarily chronological, but let's assume it is.
      *
      * @function getLastMessage
      * @param {string} address Our IOTA address
      * @returns {JSON} Parsed message or `null` when no received transfers
      */
     function getLastMessage(address) {
       return new Promise((resolve, reject) => {
         iota.api.findTransactionObjects({ addresses: [address] }, (err, transactions) => {
           if (err) return reject(err);
           if (!transactions || transactions.length === 0) return reject(new Error('No transactions retrieved.'));

           const sortedTransactions = transactions.sort((a, b) => b.timestamp - a.timestamp);
           const lastTransaction = sortedTransactions[0];
           const message = JSON.parse(iota.utils.extractJson([lastTransaction]));
           const messageWithTimeStamp = { ...message, timestamp: lastTransaction.timestamp };

           return resolve(messageWithTimeStamp);
         });
       });
     }

     const seenMessages = new Set(); // mutable set


     /**
      * Retrieves and processes an IOTA message by dispatching the type of
      * message to its handler
      * @function processIotaMessage
      * @returns {undefined}
      */
     const processIotaMessage = () => {
       const address = getAddress();
       console.log(`Getting last message from address ${address}...`);

       if (address === "") {
         console.log('No address so cannot process message');
         return;
       }

       getLastMessage(address)
        .then((msg) => {
          if (!msg) {
            console.log('No messages');
            return null;
          }

          // To avoid processing the same last message over and over we keep track
          // of already processed messages (note: stringified versions so set
          // operations that use equals (like set.has()) work as intended)
          if (seenMessages.has(JSON.stringify(msg))) {
            console.log('No new messages');
            return null;
          }
          seenMessages.add(JSON.stringify(msg));

          console.log(`Received new message of type ${msg.type}`);
          switch (msg.type) {
            case MAM_DATA_TYPE:
            {
              setRoot(msg.mamData.root);
              setSideKey(msg.mamData.sideKey);
              break;
            }
            default:
            {
              throw new Error(`Unknown message type: ${msg.type}`);
            }
        }
      })
        .catch(console.log); // eslint-disable-line no-console
     }

     // non lazy and non tail recursive take while function
     // SOURCE: https://repl.it/repls/StiffImaginaryThings
     const nil = {};
     const takeWhile = (f, [x = nil, ...xs]) => (x === nil || !f(x))
       ? [] : [x, ...takeWhile(f, xs)];

     const getRoot = () => document.getElementById('root-text-box').value;
     const setRoot = root => document.getElementById('root-text-box').value = root;
     const getSideKey = () => document.getElementById('side-key-text-box').value;
     const setSideKey = key => document.getElementById('side-key-text-box').value = key;


     /**
      * Retrieves and processes MAM messages by dispatching the type of message to
      * its handler
      *
      * @function processIotaMessage
      * @returns {undefined}
      */
     const processMamMessage = () => {
       const root = getRoot();
       const sideKey = getSideKey();
       const mode = 'restricted';

       IS_AUTHORIZED = (root !== "" && sideKey !== "");

       if (!IS_AUTHORIZED) {
         console.log('No authorization received');
         return;
       }
       console.log(`Trying to fetch from root ${root} with side key ${sideKey}`);

       Mam
         .fetch(root, mode, sideKey)
         .then(({ nextRoot, messages }) => {
           const jsonMessages = messages.map(m => JSON.parse(fromTrytes(m)));

           // Read all data messages received from this root
           const dataMessages = takeWhile(m => m.type === 'DATA', jsonMessages);
           const usage = dataMessages.map(m => ({
               date: toDate(m.timestamp),
               value: toElectricityUsage(m.raw),
             }));

           console.log(`JSON messages is ${jsonMessages}`);
           console.log(`Next root is ${nextRoot}`);
           console.log(`Usage is ${usage}`);

           if (!usage || usage.length === 0) {
             throw new Error('No data');
           }

           // Store the data messages in our backing field
           ENERGY_USAGE_DATA = usage;

           // Try retrieve the first KEY_ROTATION message
           const keyRotationMessage = jsonMessages.find(m => m.type === 'KEY_ROTATION');
           if (keyRotationMessage) {
             console.log(`Found key rotation message ${keyRotationMessage}`);
             // If contains ourselves decrypt, update ROOT and side key

             // Else drop the root and side key
             console.log('No longer authorized :(');
             setRoot("");
             setSideKey("");
           }
         })
         .then(() => drawLineChart('line-chart', ENERGY_USAGE_DATA))
         .catch(console.log);
     };

     setInterval(processIotaMessage, 5000);
     setInterval(processMamMessage, 5000);
    </script>
  </head>
  <body>
    <div class="charts-container">
      <ul>
        <li class="chart">
          <h3 class="chart-sub-headline">Wattt P1 Insights</h3>
          <h2 class="chart-headline">Electricity usage (kW)</h2>
          <div id="line-chart">
            <svg id="line-chart-svg" class="line-chart-svg">
              <text x="30" y="30" font-size="30" dy="0">
                <tspan x="0" dy=".6em">NOT AUTHORIZED</tspan>
                <tspan x="0" dy="1.2em">Request consent via</tspan>
                <tspan x="0" dy="1.2em">the button below</tspan>
              </text>
              <defs>
                <linearGradient id="line-chart-gradient-background-area" x1="0" x2="0" y1="0" y2="1">
                  <stop class="line-chart-gradient-background-area-top" offset="0%" />
                  <stop class="line-chart-gradient-background-area-bottom" offset="100%" />
                </linearGradient>
              </defs>
            </svg>
          </div>
        </li>
      </ul>
    </div>
    <label for="root-text-box">
      Goal:
    </label>
    <input id="goal-text-box"
           type="text"
           size=100
           value="display your energy usage data in a fancy graph"
    />
    <br />
    <br />
    <button onclick="requestAuthorization()">
      Request data!
    </button>
    <br />
    <br />
    <br />
    <label for="root-text-box">
      Received root:
    </label>
    <input id="root-text-box" type="text" disabled />
    <br />
    <label for="side-key-text-box">
      Received side key:
    </label>
    <input id="side-key-text-box" type="text" disabled />
    <script src="line-chart.js">
    </script>
    <script>
     // Get and set initial address
     const address = getAddress();

     if (address !== 'undefined') {
       setAddress(address);
     } else {
       const newAddress = generateAddressForTestingPurposes();
       setAddress(newAddress);
     }
    </script>
  </body>
</html>
